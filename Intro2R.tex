\documentclass[12pt]{article}
\usepackage{titlesec}
\usepackage{graphicx,setspace,hyperref,fullpage,amsmath,amsfonts,times,multirow,ccaption,tabularx,verbatim,booktabs,mdwlist}
\setlength{\marginparwidth}{.5in}
\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{}{,} %set in-line reference punctuation
\setlength{\bibsep}{0.1in} %set spacing between references
\setlength{\bibhang}{.5in} %set hanging indent for references
\setlength{\parindent}{0.5in}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\hypersetup{
    bookmarks=true,         % show bookmarks bar?
NA
NA
NA
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={Introduction to R},    % title
    pdfauthor={Thomas J. Leeper},     % author
    pdfsubject={Political Science},   % subject of the document
%    pdfkeywords={politics} {public opinion} {information acquisition} {media exposure} {time}, % list of keywords
    pdfnewwindow=true,      % links in new window
    %colorlinks=false,       % false: boxed links; true: colored links
    %linkcolor=red,          % color of internal links
    %citecolor=green,        % color of links to bibliography
    %filecolor=magenta,      % color of file links
    %urlcolor=cyan           % color of external links
    pdfborder={0 0 0}
}

\title{Really Introductory Introduction to $\mathbb{R}$}
\author{Thomas J. Leeper\\
Department of Political Science,\\
Northwestern University}



\usepackage{Sweave}
\begin{document}

\maketitle

\abstract{The purpose of this document is to provide a brief introduction to $\mathbb{R}$, focused on the core code needed to load and analyze social scientific data. While numerous other resources exist online to facilitate learning $\mathbb{R}$ and to provide guidance on performing particular procedures, this document serves as a quick-start guide catered to the needs of undergraduate Northwestern students, who have --- in past versions of this course --- expressed frustration with the technical aspects of the course. My aim in this document is to make learning $\mathbb{R}$ relatively more smooth so that you focus more of your attention on learning statistics and political science research methods and less on being frustrated with the particular software we are using to implement those ideas.\footnote{Some of this material is adapted from Teppei Yamamoto's (2009) ``Introduction to $\mathbb{R}$'' Short Course.}}

\section{Why R?}\label{sec:intro}
$\mathbb{R}$ refers to a statistical computing environment and the programming language used therein. We use $\mathbb{R}$ in this course because it is free, open source, well-documented, involves a large community of active users, and, most importantly, because it provides nearly unlimited functionality that far exceeds that of all other statistical packages.

The major drawback of using $\mathbb{R}$ is that it is difficult for new users to learn. If you have no background in programming, the learning curve can be very steep. Prior experience with statistical theory is often not terribly helpful for actually implementing that theory in $\mathbb{R}$. Prior experience with other statistical packages (Stata, SAS, SPSS, Matlab) is somewhat helpful and several texts have been written to help users of those packages transition to $\mathbb{R}$. If you have prior experience with programming in other languages, learning $\mathbb{R}$ will be relatively straightforward; BASIC, C\#, PHP, Python, Javascript, etc. all share certain similarities with $\mathbb{R}$.

A second challenge is that not a lot of effort has been put into making $\mathbb{R}$ user-friendly for those with no programming experience. It is a command-based program. There is almost nothing to ``point-and-click'' anywhere in $\mathbb{R}$. You need to learn to program in order to even use $\mathbb{R}$. When you do something wrong in $\mathbb{R}$, it will give you an error message. These errors are typically cryptic and unhelpful. Trial-and-error, use of the online help files, and use of Google will all be necessary. Your instructor and TA should not be your first resources for problems with $\mathbb{R}$. There is a wealth of information on the internet about $\mathbb{R}$ and you should plan on using your classmates as resources for troubleshooting. I am here to help you when you have exhausted these other resources. \textbf{I expect you to spend at least 20 minutes trying to solve a problem and have thoroughly read the relevant help files before emailing me.}

So why use $\mathbb{R}$ if it is so difficult to learn and so different other statistical packages that are also widely used and with which you might already be familiar? The payoff of learning can be substantial. Because $\mathbb{R}$ is a programming language, it allows you an incredible amount of flexibility for the manipulation of data, the creation of unique functions for analyzing and describing those data, and unparalleled functionality for the tabular and graphical presentation of data. For these reasons, $\mathbb{R}$ can actually be fun, once you get to know it. Being competent in $\mathbb{R}$ will make learning other programming languages and other statistical packages much easier --- skills that may prove useful and/or necessary in your future careers. And, once you know how to program and do statistical analysis, people will think you're really intelligent even if you aren't, which has its advantages on the job market.

So, let's get started with $\mathbb{R}$.

\section{Getting Started}
The first step is downloading and installing $\mathbb{R}$. This is straightforward and instructions can be found on the $\mathbb{R}$ homepage \url{http://www.r-project.org}. $\mathbb{R}$ runs on all major operating systems in effectively the exact same fashion (yet another advantage of $\mathbb{R}$!). Once you have $\mathbb{R}$ installed, you can open it and you'll be presented with a command line. This is where you tell $\mathbb{R}$ what you want to do. Because you don't know how to program any $\mathbb{R}$ code yet, try using $\mathbb{R}$ as a calculator. The standard mathematical operators all work, and follow the `order of operations.' Here are some simple examples: 
\begin{Schunk}
\begin{Sinput}
> 2+2
\end{Sinput}
\begin{Soutput}
[1] 4
\end{Soutput}
\begin{Sinput}
> 51-38
\end{Sinput}
\begin{Soutput}
[1] 13
\end{Soutput}
\begin{Sinput}
> (2+4)*6
\end{Sinput}
\begin{Soutput}
[1] 36
\end{Soutput}
\begin{Sinput}
> 20/4
\end{Sinput}
\begin{Soutput}
[1] 5
\end{Soutput}
\begin{Sinput}
> 2^3
\end{Sinput}
\begin{Soutput}
[1] 8
\end{Soutput}
\begin{Sinput}
> sqrt(4)
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\end{Schunk}

But, $\mathbb{R}$ is more than just a calculator (obviously!). To move away from using $\mathbb{R}$ as nothing more than a bloated calculator, we need to start doing some actual programming. But before we start writing more complex code, you'll probably want to move away from typing code directly into $\mathbb{R}$ and instead use another program to help you keep track of your code. There are a number of programs that can facilitate programming in $\mathbb{R}$ and dealing with its text and graphical outputs. First, you need a text editor to save the code you write. $\mathbb{R}$ doesn't automatically save the code that you tell it, so you'll save yourself a lot of time if you save all of your code in a separate program. You can use simple programs like Notepad, Wordpad, or even Word to do this, but better programs exist like TINN-R or Notepad++ (what I use), Emacs, or RStudio.\footnote{While I'd highly recommend you use a separate program to save your code, I cannot provide you any assistance with these other programs.}
\begin{itemize*}
\item Simple text editors: Notepad, TextPad, TextEdit, Wordpad (usually one or more of these is built-in with your computer's operating system)
\item Fancier editors: \textbf{\href{http://sciviews.org/Tinn-R/}{TINN-R}, \href{http://www.winedt.com/}{WinEdt}, \href{http://www.gnu.org/software/emacs/}{Emacs}, \href{http://aquamacs.org/}{Aquamacs}}, \href{http://notepad-plus-plus.org/}{Notepad++}
\item Advanced front-ends for $\mathbb{R}$: \textbf{\href{http://rstudio.org/}{RStudio}, \href{http://www.revolutionanalytics.com/products/revolution-enterprise.php}{Revolution R}, \href{http://rforge.net/JGR/}{JGR}, \href{http://www.deducer.org/pmwiki/pmwiki.php}{Deducer}}
\item Graphical User Interface for $\mathbb{R}$: \textbf{\href{http://socserv.mcmaster.ca/jfox/Misc/Rcmdr/}{Rcmdr}, \href{http://rkward.sourceforge.net/}{RKWard}}
\end{itemize*}

If you save all of your code in one of these programs with a \verb|.R| file extension, you should be able to completely replicate your analysis simply by opening this file with $\mathbb{R}$ or copying and pasting the entirety of the code into $\mathbb{R}$. This is helpful if you ask someone for help with your code because they can run all of your code and see where it may have had problems.

\subsection{Some General Notes Before Getting Started}
\begin{itemize*}
\item $\mathbb{R}$ is an object-oriented programming language. That means when we talk about particular statistics or procedures, we have to write code that tells $\mathbb{R}$ how to perform that statistical \emph{procedure} on a \emph{data object}. Usually, this looks something like \verb|mean(x)|, where \verb|mean()| is a procedure and \verb|x| is an object (specifically, a vector of data points). At first, it can be hard to distinguish what text is a procedure from what text is the label for a data object, but over time this will get easier. If you use a text editor with syntax recognition, the text editor will highlight procedures making the process of reading and writing code even easier.
\item $\mathbb{R}$ is case-sensitive. You need to type commands and variable names correctly or they will not work. As an example, \verb|Mean()| does not mean \verb|mean()|.
\item Arrow up and Arrow down on your keyboard cycle through previous commands you have entered. They do not scroll the screen up and down. Use your mouse scrollpad, Page Up and Page Down, or the scrollbar instead.
\item If you forget to put closing brackets on your commands, $\mathbb{R}$ will get confused and give you a \verb|+| symbol instead of the usual \verb|>| prompt. You can simply type the closing bracket in and the command will execute as if you typed it correctly the first time. This also means that $\mathbb{R}$ doesn't really recognize linebreaks. If you have a very long command (like for plots, which we'll talk about later), you may want to put the command on multiple lines so it is easier to read and $\mathbb{R}$ will have no problem with this, as long as you put the appropriate closing bracket at the end. If you use Mac OS or Linux OS, or some of the fancier text editors, closing brackets are often put in automatically as you type. If you're a Windows user like me, you're out of luck and need to be really careful with brackets.
\item Sometimes $\mathbb{R}$ does weird stuff that doesn't make any sense. When this happens, double check your brackets and capitalization. Then, trying Googling it. If that doesn't work, you can always just restart the program.
\end{itemize*}

\subsection{Creating constants, vectors, matrices, and dataframes}
To do statistical analysis, we need to have data. $\mathbb{R}$ has various objects for storing different types of data. The simplest way to store data is in a \emph{constant}. A constant, to $\mathbb{R}$, is just a number that is given a name. We use the \verb|<-| to store something into a particular labeled object; we can also use \verb|=| to do this; or \verb|->| by reversing the argument:
\begin{Schunk}
\begin{Sinput}
> a<-4
> a=4
> 4->a
> a
\end{Sinput}
\begin{Soutput}
[1] 4
\end{Soutput}
\end{Schunk}
Here, we've created a constant called \verb|a|, which has the value 4. $\mathbb{R}$ doesn't automatically display the value of \verb|a| when we assign a value to it. To see the value of \verb|a|, you need to simply type \verb|a| and hit <enter>. We can store multiple constants, give new values to a constant we've already defined, and then conduct mathematical operations on those constants:
\begin{Schunk}
\begin{Sinput}
> a=4
> a=6
> a
\end{Sinput}
\begin{Soutput}
[1] 6
\end{Soutput}
\begin{Sinput}
> b=3
> b+2
\end{Sinput}
\begin{Soutput}
[1] 5
\end{Soutput}
\begin{Sinput}
> b*a
\end{Sinput}
\begin{Soutput}
[1] 18
\end{Soutput}
\end{Schunk}
Note that $b*a=18$ in the code above, even though we calculated \verb|b+2| in the line directly above that calculation. You have to store a result as a constant to be able to use that result later.

Storing all of our data as individual constants, isn't very efficient, though. Let's say we want to collect a piece of data for a number of units (e.g., people in this class). We can store a set of data points as a \emph{vector} in $\mathbb{R}$ using the \verb|c()| command. Vectors can have any length and we can perform mathematical operations on vectors.

\begin{Schunk}
\begin{Sinput}
> a=c(1,2,3,4,5,6,7,8,9,10)
> a
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{Soutput}
\begin{Sinput}
> a*2
\end{Sinput}
\begin{Soutput}
 [1]  2  4  6  8 10 12 14 16 18 20
\end{Soutput}
\begin{Sinput}
> b=a
> b
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{Soutput}
\end{Schunk}

You can also create a sequence of numbers using \verb|seq()| or just the \verb|:|.
\begin{Schunk}
\begin{Sinput}
> a=seq(1:10)
> a
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{Soutput}
\begin{Sinput}
> b=1:10
> b
\end{Sinput}
\begin{Soutput}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{Soutput}
\end{Schunk}

This is especially helpful if we want to calculate any basic statistics on a particular vector of data (what we might, in social science language, call a variable). Let's imagine for instance that we collect a number of 2-dice rolls and record the sum in a vector called dice. We can then find out a number of pieces of information about this set of rolls.

\begin{Schunk}
\begin{Sinput}
> dice=c(2,2,3,4,4,5,5,5,5,5,6,6,7,7,7,7,8,9,10,11)
> table(dice) #a simple tabulation of how many of each value are in the vector
\end{Sinput}
\begin{Soutput}
dice
 2  3  4  5  6  7  8  9 10 11 
 2  1  2  5  2  4  1  1  1  1 
\end{Soutput}
\begin{Sinput}
> fivenum(dice) #the five number summary (min, Q1, median, Q3, max) for the vector
\end{Sinput}
\begin{Soutput}
[1]  2.0  4.5  5.5  7.0 11.0
\end{Soutput}
\begin{Sinput}
> quantile(dice, c(0.1,0.2,0.6,0.8)) #arbitrary quantiles
\end{Sinput}
\begin{Soutput}
10% 20% 60% 80% 
2.9 4.0 6.4 7.2 
\end{Soutput}
\begin{Sinput}
> summary(dice) #a set of basic univariate statistics for the vector
\end{Sinput}
\begin{Soutput}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   2.00    4.75    5.50    5.90    7.00   11.00 
\end{Soutput}
\end{Schunk}

Note we can also obtain these summary values individually.
\begin{Schunk}
\begin{Sinput}
> dice=c(2,2,3,4,4,5,5,5,5,5,6,6,7,7,7,7,8,9,10,11)
> length(dice) #how many observations are there?
\end{Sinput}
\begin{Soutput}
[1] 20
\end{Soutput}
\begin{Sinput}
> min(dice) #minimum
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\begin{Sinput}
> median(dice) #median
\end{Sinput}
\begin{Soutput}
[1] 5.5
\end{Soutput}
\begin{Sinput}
> max(dice) #maximum
\end{Sinput}
\begin{Soutput}
[1] 11
\end{Soutput}
\begin{Sinput}
> max(dice)-min(dice) #range
\end{Sinput}
\begin{Soutput}
[1] 9
\end{Soutput}
\begin{Sinput}
> sum(dice)
\end{Sinput}
\begin{Soutput}
[1] 118
\end{Soutput}
\begin{Sinput}
> sum(dice)/length(dice)
\end{Sinput}
\begin{Soutput}
[1] 5.9
\end{Soutput}
\begin{Sinput}
> mean(dice) #mean
\end{Sinput}
\begin{Soutput}
[1] 5.9
\end{Soutput}
\begin{Sinput}
> v=var(dice) #variance
> v
\end{Sinput}
\begin{Soutput}
[1] 5.884211
\end{Soutput}
\begin{Sinput}
> sqrt(v) #standard deviation
\end{Sinput}
\begin{Soutput}
[1] 2.425739
\end{Soutput}
\begin{Sinput}
> sd(dice) #easier way of getting standard deviation
\end{Sinput}
\begin{Soutput}
[1] 2.425739
\end{Soutput}
\end{Schunk}

One thing that can be initially confusing for new users of $\mathbb{R}$ is exactly what is happening when you type in a given command. $\mathbb{R}$ does not solve mathematical equations. Instead, like any programming language, it performs a set of procedures in a specific order on a particular data object (i.e., it performs an algorithm). What does an algorithm look like and why does it matter? To use $\mathbb{R}$ effectively, one needs to understand what it is doing and how to think in algorithms rather than equations. Think about the formula for the mean of a set of data (like our dice roll data). The mathematical equation is $\bar{x}=\sigma x_{i} / n$.



Two important tips here. First, you can use the \verb|round()| command to round a given value to a specified number of decimal places. Second, you can nest commands inside of one another rather than produce a constant that you'll only use one time (e.g., to calculate the standard deviation we can create a constant that stores the variance and take the square root thereof O$\mathbb{R}$ we can simply take the square root of the variance directly).
\begin{Schunk}
\begin{Sinput}
> round(mean(dice),2)
\end{Sinput}
\begin{Soutput}
[1] 5.9
\end{Soutput}
\begin{Sinput}
> round(sqrt(var(dice)),2)
\end{Sinput}
\begin{Soutput}
[1] 2.43
\end{Soutput}
\end{Schunk}

We can also extract one or more observations from a vector. For instance, if we wanted to know the value of the 1st through 3rd rolls, or just the value of the 7th roll:
\begin{Schunk}
\begin{Sinput}
> dice=c(2,2,3,4,4,5,5,5,5,5,6,6,7,7,7,7,8,9,10,11)
> dice[1:3]
\end{Sinput}
\begin{Soutput}
[1] 2 2 3
\end{Soutput}
\begin{Sinput}
> dice[7]
\end{Sinput}
\begin{Soutput}
[1] 5
\end{Soutput}
\end{Schunk}
We'll discuss more about extracting particular observations in a moment. Clearly, though, conducting simple analyses in $\mathbb{R}$ is pretty straightfoward. Most of the commands are semantic --- that is, the command to obtain a particular statistic is intuitive. This is generally the case, but can get confusing once we move into more advanced statistics. Using comments in your $\mathbb{R}$ programming will therefore be vital to you and I both understanding what you're trying to do with a given piece of code. The pound sign (\#) can be used to create comments in the code, which can be helpful when you have to do complex things in your code and you want to remind yourself (or me) what you're trying to do with each bit of code. They can be included at the end of a line of code or simply on their own. Just start the line with a pound sign and then continue with code on the next line.

Now let's work with two variables. Let's try comparing two sets of dice rolls, by looking at their means, variances, and the correlation between the two sets of rolls.
\begin{Schunk}
\begin{Sinput}
> dice1=c(7,7,4,5,3,6,8,2,12,10)
> dice2=c(8,4,7,7,7,7,6,6,3,4)
> mean(dice1)
\end{Sinput}
\begin{Soutput}
[1] 6.4
\end{Soutput}
\begin{Sinput}
> sd(dice1)
\end{Sinput}
\begin{Soutput}
[1] 3.098387
\end{Soutput}
\begin{Sinput}
> mean(dice2)
\end{Sinput}
\begin{Soutput}
[1] 5.9
\end{Soutput}
\begin{Sinput}
> sd(dice2)
\end{Sinput}
\begin{Soutput}
[1] 1.66333
\end{Soutput}
\begin{Sinput}
> cor(dice1,dice2)
\end{Sinput}
\begin{Soutput}
[1] -0.6812877
\end{Soutput}
\end{Schunk}

We could also represent these data a different way. Rather than having two vectors, we could ``column bind'' them (using the \verb|cbind()| command) into a \emph{matrix}, which we can also call whatever we want.
\begin{Schunk}
\begin{Sinput}
> dice1=c(7,7,4,5,3,6,8,2,12,10)
> dice2=c(8,4,7,7,7,7,6,6,3,4)
> dice=c(dice1,dice2)
> set=c(1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2)
> dice.mat=cbind(set,dice)
> dice.mat
\end{Sinput}
\begin{Soutput}
      set dice
 [1,]   1    7
 [2,]   1    7
 [3,]   1    4
 [4,]   1    5
 [5,]   1    3
 [6,]   1    6
 [7,]   1    8
 [8,]   1    2
 [9,]   1   12
[10,]   1   10
[11,]   2    8
[12,]   2    4
[13,]   2    7
[14,]   2    7
[15,]   2    7
[16,]   2    7
[17,]   2    6
[18,]   2    6
[19,]   2    3
[20,]   2    4
\end{Soutput}
\end{Schunk}

We can also use the corresponding \verb|rbind()| to ``row bind'' two or more vectors, which has the same effect as \verb|cbind()|, but treats each vector as a row/observation. The \verb|t()| command transposes a matrix. If we apply this function to our original matrix (that we constructed using \verb|cbind()|), we will obtain the second matrix we constructed (using \verb|rbind()|).
\begin{Schunk}
\begin{Sinput}
> rbind(set,dice)
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
set     1    1    1    1    1    1    1    1    1     1     2     2     2     2
dice    7    7    4    5    3    6    8    2   12    10     8     4     7     7
     [,15] [,16] [,17] [,18] [,19] [,20]
set      2     2     2     2     2     2
dice     7     7     6     6     3     4
\end{Soutput}
\begin{Sinput}
> t(dice.mat)
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
set     1    1    1    1    1    1    1    1    1     1     2     2     2     2
dice    7    7    4    5    3    6    8    2   12    10     8     4     7     7
     [,15] [,16] [,17] [,18] [,19] [,20]
set      2     2     2     2     2     2
dice     7     7     6     6     3     4
\end{Soutput}
\end{Schunk}

Here, we created our vectors from above, but then combined them into a single vector using the \verb|c()| command. We then created a separate vector called \verb|set| into which we stored the identifier for whether the observation came from our first or second set of rolls. We then bound these two vectors together into a matrix called \verb|dice.mat|, which has dimensions 20 x 2. Now this is starting to look like a traditional rectangular dataset where each observation is represented as a row and each variable is a column. We can look at the dimensions of the new matrix, including its number of columns and number of rows and use that information to extract particular values (or sets of values) from the matrix. We can extract a particular observation (e.g., observation 5), a particular variable (e.g., the second variable), or the observation for a given variable (e.g., the value of the roll for our fifth roll) just as we did with vectors, but now our syntax reflects that row and column position, as follows:
\begin{Schunk}
\begin{Sinput}
> ncol(dice.mat)
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\begin{Sinput}
> nrow(dice.mat)
\end{Sinput}
\begin{Soutput}
[1] 20
\end{Soutput}
\begin{Sinput}
> dim(dice.mat) #obtain both dimensions
\end{Sinput}
\begin{Soutput}
[1] 20  2
\end{Soutput}
\begin{Sinput}
> dice.mat[5,]
\end{Sinput}
\begin{Soutput}
 set dice 
   1    3 
\end{Soutput}
\begin{Sinput}
> dice.mat[,2]
\end{Sinput}
\begin{Soutput}
 [1]  7  7  4  5  3  6  8  2 12 10  8  4  7  7  7  7  6  6  3  4
\end{Soutput}
\begin{Sinput}
> dice.mat[5,2]
\end{Sinput}
\begin{Soutput}
dice 
   3 
\end{Soutput}
\end{Schunk}

We could continue to bind vectors to this matrix. For example, we could bind a vector to the matrix that identifies the color the dice we rolled. Here we'll be dealing with a vector of \emph{strings}, which we cannot perform statistical or mathematical operations, but that we often find in real world data.
\begin{Schunk}
\begin{Sinput}
> color=c("red","red","blue","yellow","blue","red","red","blue","yellow","blue","red","red","blue","yellow","blue","red","red","blue","yellow","blue")
> dice.mat2=cbind(dice.mat,color)
> dice.mat2
\end{Sinput}
\begin{Soutput}
      set dice color   
 [1,] "1" "7"  "red"   
 [2,] "1" "7"  "red"   
 [3,] "1" "4"  "blue"  
 [4,] "1" "5"  "yellow"
 [5,] "1" "3"  "blue"  
 [6,] "1" "6"  "red"   
 [7,] "1" "8"  "red"   
 [8,] "1" "2"  "blue"  
 [9,] "1" "12" "yellow"
[10,] "1" "10" "blue"  
[11,] "2" "8"  "red"   
[12,] "2" "4"  "red"   
[13,] "2" "7"  "blue"  
[14,] "2" "7"  "yellow"
[15,] "2" "7"  "blue"  
[16,] "2" "7"  "red"   
[17,] "2" "6"  "red"   
[18,] "2" "6"  "blue"  
[19,] "2" "3"  "yellow"
[20,] "2" "4"  "blue"  
\end{Soutput}
\end{Schunk}

We can also transform this matrix into a different type of $\mathbb{R}$ object called a \emph{dataframe}. Matrices and dataframes have some similar properties, but also differences that you will learn over the course of this course. Importantly, most data that we read in from an outside file (as opposed to typing in ourselves) will be in the form of a dataframe. But, we can also transform our matrix into a dataframe. If you want to know whether something is a matrix or a dataframe, you can also test it using an \verb|is.matrix()| or \verb|is.data.frame()| command.
\begin{Schunk}
\begin{Sinput}
> dataframe=as.data.frame(dice.mat2)
> is.data.frame(dataframe)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\begin{Sinput}
> is.matrix(dataframe)
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\begin{Sinput}
> is.data.frame(dice.mat2)
\end{Sinput}
\begin{Soutput}
[1] FALSE
\end{Soutput}
\begin{Sinput}
> is.matrix(dice.mat2)
\end{Sinput}
\begin{Soutput}
[1] TRUE
\end{Soutput}
\end{Schunk}

One of the key advantages of dataframes is that we can refer to columns of the dataframe by their variable names, as opposed to their position number (as we have to do with matrices). We can find these names using the \verb|names()| command and isolate a particular column of the matrix by using the dollar sign operator. Note that this produces the same result as using the brackets to identify the particular column (as we did above with our matrix).
\begin{Schunk}
\begin{Sinput}
> names(dataframe)
\end{Sinput}
\begin{Soutput}
[1] "set"   "dice"  "color"
\end{Soutput}
\begin{Sinput}
> dataframe$color
\end{Sinput}
\begin{Soutput}
 [1] red    red    blue   yellow blue   red    red    blue   yellow blue  
[11] red    red    blue   yellow blue   red    red    blue   yellow blue  
Levels: blue red yellow
\end{Soutput}
\begin{Sinput}
> dataframe[,3]
\end{Sinput}
\begin{Soutput}
 [1] red    red    blue   yellow blue   red    red    blue   yellow blue  
[11] red    red    blue   yellow blue   red    red    blue   yellow blue  
Levels: blue red yellow
\end{Soutput}
\end{Schunk}

We can also extract a column or row from a dataframe and turn it into a vector. We might want to do this if we plan on transforming the data in some way and saving that transformed data for later use. We could also add that new vector back into the dataframe under a new name. The vector and column in the dataframe will have the same properties, but changing one has no effect on the other. This aspect can sometimes get confusing, especially once you start working with data that contains many variables. You can have a column in a dataframe and a separate vector that have the same name. To work with the vector simply use the name, to use the column in the dataframe, you have to use the \verb|$| operator.
\begin{Schunk}
\begin{Sinput}
> df=as.data.frame(dice.mat)
> df$dice
\end{Sinput}
\begin{Soutput}
 [1]  7  7  4  5  3  6  8  2 12 10  8  4  7  7  7  7  6  6  3  4
\end{Soutput}
\begin{Sinput}
> half=df$dice+1
> df$half=half
> summary(half)
\end{Sinput}
\begin{Soutput}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    5.00    7.50    7.15    8.00   13.00 
\end{Soutput}
\begin{Sinput}
> summary(df$half)
\end{Sinput}
\begin{Soutput}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    5.00    7.50    7.15    8.00   13.00 
\end{Soutput}
\begin{Sinput}
> half=half+1
> summary(half)
\end{Sinput}
\begin{Soutput}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   4.00    6.00    8.50    8.15    9.00   14.00 
\end{Soutput}
\begin{Sinput}
> summary(df$half)
\end{Sinput}
\begin{Soutput}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   3.00    5.00    7.50    7.15    8.00   13.00 
\end{Soutput}
\end{Schunk}

Be careful here, because you can also accidentally change a vector by giving something else the same name. For example, we can eliminate the vector entirely by assigning a constant value to it or by giving it the missing value code \verb|NA|.
\begin{Schunk}
\begin{Sinput}
> half
\end{Sinput}
\begin{Soutput}
 [1]  9  9  6  7  5  8 10  4 14 12 10  6  9  9  9  9  8  8  5  6
\end{Soutput}
\begin{Sinput}
> half=1
> half
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\begin{Sinput}
> half=NA
> half
\end{Sinput}
\begin{Soutput}
[1] NA
\end{Soutput}
\end{Schunk}

We can apply the same \verb|summary()| and \verb|table()| commands that we used on vectors to matrices and dataframes. We can also use \verb|table()| on two variables to construct crosstabs.
\begin{Schunk}
\begin{Sinput}
> summary(df)
\end{Sinput}
\begin{Soutput}
      set           dice            half      
 Min.   :1.0   Min.   : 2.00   Min.   : 3.00  
 1st Qu.:1.0   1st Qu.: 4.00   1st Qu.: 5.00  
 Median :1.5   Median : 6.50   Median : 7.50  
 Mean   :1.5   Mean   : 6.15   Mean   : 7.15  
 3rd Qu.:2.0   3rd Qu.: 7.00   3rd Qu.: 8.00  
 Max.   :2.0   Max.   :12.00   Max.   :13.00  
\end{Soutput}
\begin{Sinput}
> table(df$dice,df$set) #crosstab
\end{Sinput}
\begin{Soutput}
     1 2
  2  1 0
  3  1 1
  4  1 2
  5  1 0
  6  1 2
  7  2 4
  8  1 1
  10 1 0
  12 1 0
\end{Soutput}
\begin{Sinput}
> with(df,table(dice,set)) #an alternative method for getting crosstabs
\end{Sinput}
\begin{Soutput}
    set
dice 1 2
  2  1 0
  3  1 1
  4  1 2
  5  1 0
  6  1 2
  7  2 4
  8  1 1
  10 1 0
  12 1 0
\end{Soutput}
\begin{Sinput}
> prop.table(table(df$dice,df$set)) #convert cell counts to proportions
\end{Sinput}
\begin{Soutput}
        1    2
  2  0.05 0.00
  3  0.05 0.05
  4  0.05 0.10
  5  0.05 0.00
  6  0.05 0.10
  7  0.10 0.20
  8  0.05 0.05
  10 0.05 0.00
  12 0.05 0.00
\end{Soutput}
\end{Schunk}

Sometimes you want to know all the objects you have created. To see these, use the \verb|ls()| command.
\begin{Schunk}
\begin{Sinput}
> ls()
\end{Sinput}
\begin{Soutput}
 [1] "a"         "b"         "color"     "dataframe" "df"        "dice"     
 [7] "dice.mat"  "dice.mat2" "dice1"     "dice2"     "filename"  "filenames"
[13] "half"      "set"       "v"         "wd"       
\end{Soutput}
\end{Schunk}
You can also use \verb|rm(list=ls(all=TRUE))| to clear all objects; this effectively starts a new $\mathbb{R}$ instance because you will lose all of your work.

\subsection{$\mathbb{R}$ Output}
Just as it is helpful to save your $\mathbb{R}$ code in an outside file, it is also sometimes helpful to send the output of $\mathbb{R}$ to an outside file so that you can retrieve it later. $\mathbb{R}$ provides the \verb|sink()| command to allow you to put all of the output it produces into an outside .txt file in addition to (or instead of) sending the output to the $\mathbb{R}$ console. This can be helpful when you start performing a large number of analyses. (You need to enter the \verb|sink()| command, complete with all its arguments before conducting your analyses.)

\section{Working with Real Data}\label{sec:data}
Now that we've worked with some of the basic manipulations of data and the type of objects that $\mathbb{R}$ understands (constants, vectors, matrices, and dataframes), we can proceed forward by working with actual data. It is rare that we'll have to enter our own data manually into $\mathbb{R}$. Instead, we'll likely have to import it from an outside file of various types. To this, we have to start by telling $\mathbb{R}$ where to find the data. You can either do this visually by selecting \verb|File > change dir|, or you can use the \verb|setwd()| command.\footnote{The file path you use will depend on your operating system and the folder where you have saved the data file on your computer. See the $\mathbb{R}$ help files for how to do this. You can access the help file by typing \textbf{? setwd()} into $\mathbb{R}$. You can use that question mark syntax to get help on any $\mathbb{R}$ command.} This sets the working directory for your current $\mathbb{R}$ session. You can change it later as needed, but you'll need to set it each time you work with $\mathbb{R}$.
\begin{Schunk}
\begin{Sinput}
> setwd("C:/Users/Thomas/Documents/NU-Teaching/Introduction2R/")
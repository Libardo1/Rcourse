<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Missing data handling</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



</head>

<body>
<h1>Missing data handling</h1>

<p>Missing data is a pain. It creates problems for simple and complicated analyses. It also tend to undermine our ability to make valid inferences.
Most statistical packages tend to &ldquo;brush missing data under the rug&rdquo; and simply delete missing cases on the fly. This is nice because it makes analysis simple: e.g., if you want a mean of a variable with missing data, most packages drop the missing data and report the mean of the remaining values.
But, a different view is also credible: the assumption that we should discard missing values may be a bad assumption. For example, let&#39;s say that we want to build a regression model to explain two outcomes but those outcome variables have different patterns of missing data. If we engage in &ldquo;on-the-fly&rdquo; case deletion, then we end up with two models that are built on different, non-comparable subsets of the original data. We are then limited in our ability to compare, e.g., the coefficients from one model to the other because they have different data bases.
Choosing how to deal with missing values is thus better done as an intentional activity early in the process of data analysis rather than as an analysis-specific assumption.</p>

<p>This tutorial demonstrates some basic missing data handling procedures. A separate tutorial on multiple imputation covers advanced techniques.</p>

<h2>Local NA handling</h2>

<p>When R encounters missing data, its typical behavior is to attempt to perform the requested procedure and then returns a missing (<code>NA</code>) value as a result. We can see this if we attempt to calculate the mean of a vector containing missing data:</p>

<pre><code class="r">x &lt;- c(1, 2, 3, NA, 5, 7, 9)
mean(x)
</code></pre>

<pre><code>## [1] NA
</code></pre>

<p>R is telling us here that our vector contains missing data, so the requested statistic - the mean - is undefined for these data. If we want to do - as many statistical packages do by default - and calculate the mean by dropping the missing value, we just need to request that R remove the missing values using the <code>na.rm=TRUE</code> argument:</p>

<pre><code class="r">mean(x, na.rm = TRUE)
</code></pre>

<pre><code>## [1] 4.5
</code></pre>

<p><code>na.rm</code> can be found in many R functions, such as <code>mean</code>, <code>median</code>, <code>sd</code>, <code>var</code>, and so forth.
One exception to this is the <code>summary</code> function when applied to a vector of data. By default it counts missing values and then reports the mean, median, and other statistics excluding those value:</p>

<pre><code class="r">summary(x)
</code></pre>

<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
##    1.00    2.25    4.00    4.50    6.50    9.00       1
</code></pre>

<p>Another common function that handles missing values atypically is the correlation (<code>cor</code>) function. Rather than accepting an <code>na.rm</code> argument, it has a <code>use</code> argument that specifies what set of cases to use when calculating the correlation coefficient. Its default behavior - like <code>mean</code>, <code>median</code>, etc. - is to attempt to calculate the correlation coefficient with <code>use=&quot;everything&quot;</code>. This can result in an <code>NA</code> result:</p>

<pre><code class="r">y &lt;- c(3, 2, 4, 5, 1, 3, 4)
cor(x, y)
</code></pre>

<pre><code>## [1] NA
</code></pre>

<p>The <code>use</code> argument can take several values (see <code>?cor</code>), but the two most common useful are <code>use=&quot;complete.obs&quot;</code> and <code>use=&quot;pairwise.complete.obs&quot;</code>. The former deletes all cases with missing values before calculating the correlation. The latter applies where trying to build a correlation matrix (i.e., correlations between more than two variables) and instead of dropping all cases with any missing data, it only drops cases from each pairwise correlation calculation. We can see this if we build a three-variable matrix:</p>

<pre><code class="r">z &lt;- c(NA, 2, 3, 5, 4, 3, 4)
m &lt;- data.frame(x, y, z)
m
</code></pre>

<pre><code>##    x y  z
## 1  1 3 NA
## 2  2 2  2
## 3  3 4  3
## 4 NA 5  5
## 5  5 1  4
## 6  7 3  3
## 7  9 4  4
</code></pre>

<pre><code class="r">cor(m)  # returns all NAs
</code></pre>

<pre><code>##    x  y  z
## x  1 NA NA
## y NA  1 NA
## z NA NA  1
</code></pre>

<pre><code class="r">cor(m, use = &quot;complete.obs&quot;)
</code></pre>

<pre><code>##        x       y       z
## x 1.0000 0.34819 0.70957
## y 0.3482 1.00000 0.04583
## z 0.7096 0.04583 1.00000
</code></pre>

<pre><code class="r">cor(m, use = &quot;pairwise.complete.obs&quot;)
</code></pre>

<pre><code>##        x      y      z
## x 1.0000 0.2498 0.7096
## y 0.2498 1.0000 0.4534
## z 0.7096 0.4534 1.0000
</code></pre>

<p>Under default settings, the response is a matrix of <code>NA</code> values. With <code>use=&quot;complete.obs&quot;</code>, the matrix <code>m</code> first has all cases with missing values removed, then the correlation matrix is produced. Whereas with <code>use=&quot;pairwise.complete.obs&quot;</code>, the cases with missing values are only removed during the calculation of each pairwise correlation. Thus we see that the correlation between <code>x</code> and <code>z</code> is the same in both matrices but the correlation between <code>y</code> and both <code>x</code> and <code>z</code> depends on the <code>use</code> method (with dramatic effect).</p>

<h2>Regression NA handling</h2>

<p>Another places where missing data are handled atypically is in regression modeling. If we estimate a linear regression model for our <code>x</code>, <code>z</code>, and <code>y</code> data, R will default to casewise deletion. We can see this here:</p>

<pre><code class="r">lm &lt;- lm(y ~ x + z, data = m)
summary(lm)
</code></pre>

<pre><code>## 
## Call:
## lm(formula = y ~ x + z, data = m)
## 
## Residuals:
##      2      3      5      6      7 
## -0.632  1.711 -1.237 -0.447  0.605 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)
## (Intercept)    3.316      3.399    0.98     0.43
## x              0.289      0.408    0.71     0.55
## z             -0.632      1.396   -0.45     0.70
## 
## Residual standard error: 1.65 on 2 degrees of freedom
##   (2 observations deleted due to missingness)
## Multiple R-squared:  0.203,  Adjusted R-squared:  -0.594 
## F-statistic: 0.254 on 2 and 2 DF,  p-value: 0.797
</code></pre>

<p>The model, obviously, can only fit the model to the available data, so the resulting fitted values have a different length from the original data:</p>

<pre><code class="r">length(m$y)
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r">length(lm$fitted)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<p>Thus, if we tried to store our fitted values back into our <code>m</code> dataframe (e.g., using <code>m$fitted &lt;- lm$fitted</code>) or plot our model residuals against the original outcome <code>y</code> (e.g., with <code>plot(lm$residuals ~ m$y)</code>), we would encounter an error.
This is typical of statistical packages, but highlights that we should really address missing data before we start any of our analysis.</p>

<h2>Global NA handling</h2>

<p>How do we deal with missing data globally? Basically, we need to decide how we&#39;re going to use our missing data, if at all, then either remove cases from our data or impute missing values, and then proceed with our analysis. As mentioned, one strategy is multiple imputation, which is addressed in a separate tutorial.
Before we deal with missing data, it is helpful to know where it lies in our data:
We can look for missing data in a vector by simply wrapping it in <code>is.na</code>:</p>

<pre><code class="r">is.na(x)
</code></pre>

<pre><code>## [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
</code></pre>

<p>We can also do the same for an entire dataframe:</p>

<pre><code class="r">is.na(m)
</code></pre>

<pre><code>##          x     y     z
## [1,] FALSE FALSE  TRUE
## [2,] FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE
## [4,]  TRUE FALSE FALSE
## [5,] FALSE FALSE FALSE
## [6,] FALSE FALSE FALSE
## [7,] FALSE FALSE FALSE
</code></pre>

<p>That works fine in our small example, but in a very large dataset, that could get quite difficult to understand. Therefore, it is helpful to visualize missing data in a plot. We can use the <code>image</code> function to visualize the <code>is.na(m)</code> matrix:</p>

<pre><code class="r">image(is.na(m), main = &quot;Missing Values&quot;, xlab = &quot;Observation&quot;, ylab = &quot;Variable&quot;, 
    xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, bty = &quot;n&quot;)
axis(1, seq(0, 1, length.out = nrow(m)), 1:nrow(m), col = &quot;white&quot;)
axis(2, c(0, 0.5, 1), names(m), col = &quot;white&quot;, las = 2)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAAolBMVEX9/v0AAAAAADkAAGUAOTkAOWUAOY8AZrU5AAA5ADk5AGU5OQA5OWU5OY85ZmU5ZrU5j9plAABlADllAGVlOQBlOY9lZjllZmVlj49ltbVltf2POQCPOTmPOWWPZgCPtY+P27WP29qP2/21ZgC1Zjm1tWW124+1/rW1/v3ajzna24/a/rXa/tra/v39tWX924/9/rX9/tr9/v3/AAD//9X////KqItuAAAANnRSTlP//////////////////////////////////////////////////////////////////wD///9SiKdNAAAACXBIWXMAAAsSAAALEgHS3X78AAAKs0lEQVR4nO3cjXraRgJG4creAklLK+JkvQtuk6JuY20DEmp7/7e2M/qxbOzGwwhWM/rOeVzjYmQZXmYkYZRvKpLsm7F/ARon4EUDXjTgRQNeNOBFA1404EUDXjTgRQNeNOBFA1404EUDXjTgRQNeNOBFA1404EUDXjTgRQNeNOBFA160acIfNkmSmss8SWa7cnV9f3yDl67rllybi71Z7rWbxt1U4a++M3LW/wHQsTyZm89Z/bypAz6iDPw/DVe5+mHRjvhikSQWsL201x021/9prjRPkOvPq+YpUizab5tRnyRX2+6m9kp7CzOJ1HNC9wNjbbLwHxdrQ/evFr5cGa962u8urab92gzw+ot/LBp4s+jWqM6rpzft4LN6mfThu2PfU+8mC/9plVb59W8tfLHoxnNz2cKn9ca8HuR5p5iba/N6UDc3ewJfL2//r/tB0TZZ+G02+7KZ/ffxiK/xkkdTfT2Rz3Z7u1kv26nefvFlU0/i9sZH8Pt6wJstQPeDom268LnZbKfF4218Uk/irdsTzcfwVWY2E2mzEf97+IcfGGvThS8Wt/bTo8O5rJ3AzeXR/P14qrc7dRbUTvn2O+1WYV3f4ukM3/3AGJsuvJmMm01xs41vhu+Lw/jJzl09w9svm8Hd3LTdp3vYubPPgCTuuX668MZoXj2Z6u04bi+f7qrb58jnh6m+O4g3xmneTA715v7f9S2ydme++4GxNk14j/YxH5t5BHzVHpP3r9VJBHzVbs7nY/8W/9+AFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YbA/+nfH3TpgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAX7UzwWZIkc+Aj6kzwVXW427Zf/dUFfMCdDT5Pj68BPuTOBV8sd8DH1Jng+4ke+Dg6E/zziR74sDsPfLkye/XJET7wIXce+BcDPuSAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAF+2S8GPfN/pKwIsGvGjAiwa8aMCLBrxowIsGvGjAiwa8aMCLBrxowIsGvGjAiwa8aMCLBrxowIsGvGjAiwa8aMCLBrxowIsGvGjAiwa8aMCLBrxowIsGvGjAiwa8aMCLBrxowIsGvGjAi+YGf9gks9/fbYGfTk7wh01aLHf72Q74yeQEX97cG3jzGfjJ5ATfjPicET+hnODtNj5JTnQHPujc4L0CPuSAF80BvlwlTdfs3E0nB3jfgA854EVzg6/36ufATygneHMcbz5zHD+lnOCb1+x45W5KOcFXWT3iT5zrgQ85B3gO56aYA7xvwIcc8KK5wedM9VPLCb58t93P2bmbVG7wN/fNB/CTyQn+cLc1H8Vb4KeTE3xlzPdJkv797bJ1VSyPXtgDPuTc4F9tn9qPFrxr7PtGX+lM8OWH3a/H774GPuQc4Mubz6vXDucOd58+HP8JB/iQc4B3Kr99tgcAfMg5wTscyBVvnp1nA3zIOcGbY7nX4A8/PXtuAB9yTvDlq9v4qvjx2VXAh5wT/OvlV8/nBOBD7kzwLwV8yLnB89e5yeUEz1/nppcbPH+dm1xO8Px1bno5wb/+1zngY8sN3ivgQw540Rzgy9ULr84AH3kO8PU5k6eeMQl84DnBm/anvnwDfNi5wtsZn1fuJpQr/MnswIedE7zZxp/MDnzYOcCzVz/FHOB9Az7kgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGAFw140YAXDXjRgBcNeNGA7/tzQGP/7icHfB/wwAMPPPDAAw888MADD3xEAd8HPPDAAw888MADDzzwwAMfUcD3AQ888MADDzzwwAMPPPDARxTwfcADDzzwwAMPPPDAAw888BEFfB/wwAMPPPDAAw888MADD3xEAd8HPPDAAw888MADDzzwwAMfUcD3AQ888MADDzzwwAMPPPDARxTwfcADDzzwwAMPPPDAAw888BEFfB/wwAMPPPDAA/+sLK3yOfARdSb48ubzzX0H3jX2fTs14E+Hr/IkPb5q7Lt2csB7wBdvtsDH1Lngs9vjTTzwQXcm+GL55e54yI99104O+JPhD5t1tZ/tgI+n88C/2Nh37eSABx544IEHHnjggQceeOAjCvg+4IEHHnjggQceeOCBBx74iAK+D3jggQceeOCBBx544IEHPqKA7wMeeOCBBx544IEHHnjggY8o4PuABx544IEHHnjggQceeOAjCvg+4IEHHnjggQceeOCBBx74iAK+D3jggQceeOCBBx544IEHPqKA7wMeeOCBBx544IEHHnjggY+oC8J/tb/o8g3wuRz8KIuOtNr47izwES8K/Oirje/OAh/xosCPvtr47izwES8K/Oirje/OXg6ewg540YAXDXjRgBcNeNGAFw140YAXDXjRLgVfvL33XHCRJGvPle6T5NpztVV12HiuNk+8V3vYJFdb/7X6P1IXg9/7PhTlu21VvPF7MOyTLZ97LVrZR9LzUcz8H32z6H628158yLKXgc+uPnqO+L2FG/BQ+s8037/3W+vhznPMmmf5jff8VC/+znvNAU711bA75DviD3e/eE715cp7yi2WP3tP9ZX/fa0LEP6wSb3XuvDeZKa+23i7YfIc9cVibfB9p+tBAz5A+HLl7V55Pxrm4ffeubP5bZwsuj/fkC18gPB2FAzJj6DZR/Z/xvmttfwwBD4bMkCCgx/iboeA/+PoO+LtWg8/+d3bbMBUP2Cn0hYa/KDDU7Ow/77SkON437WaHUPvFx6GbeJ55U414EUDXjTgRQNeNOBFA1404EUDXjTgRQNeNOBFA1404EUDXjTgRQNeNOBFA1404EVTgs/bt3G6vBe6eHs/5GSg8BOCz+27r+3ZGo7wl/+NxkwHvjlD0YJmt/XIb0+qbt7iXHz/PrFvkL/b1udp2yt/Mzdtv7n8ecgZyUGmA9+ccWTfPZ/NdsbfPhHsaYdZai+KxdqeoVAsf7fnadfzfP0cSe1yxSIdeMJSeAnBN+eWmnneTvXZuj0hwV6Y50B9bn1qP6qq/f/2yWFuYL85tblfDd6O+F+3zclLC3sGTH2W81Vju/xiT0vK7CagH/R29gc+4h5t49fd+VJm/m7/cYKG+ONyV67W/VTPiJ9C+fV9u1c/t4x2o23/azfj1jVP0hq4eLN9uo0HPur23XH8bX2WY/awV3+1bVzrf3zHHO1/+3592DzeqweephLwogEvGvCiAS8a8KIBLxrwogEvGvCiAS8a8KIBLxrwogEvGvCiAS8a8KL9DzKZxs08G13lAAAAAElFTkSuQmCC" alt="plot of chunk unnamed-chunk-10"/> </p>

<p>Note: The syntax here is a little bit tricky, but it is simply to make the plot easier to understand. See <code>?image</code> for more details.
The plot shows we have two missing values: one in our <code>z</code> variable for observation 1 and one in our <code>x</code> variable for observation 4.
This plot can help us understand where our missing data is and if we systematically observe missing data for certain types of observations.</p>

<p>Once we know where our missing data are, we can deal with them in some way.
Casewise deletion is the easiest way to deal with missing data. It simply removes all cases that have missing data anywhere in the data.
To do casewise deletion, we simply using the <code>na.omit</code> function on our entire dataframe:</p>

<pre><code class="r">na.omit(m)
</code></pre>

<pre><code>##   x y z
## 2 2 2 2
## 3 3 4 3
## 5 5 1 4
## 6 7 3 3
## 7 9 4 4
</code></pre>

<p>In our example data, this procedure removes two rows that contain missing values.
Note: using <code>na.omit(m)</code> does not affect our original object <code>m</code>. To use the new dataframe, we need to save it as an object:</p>

<pre><code class="r">m2 &lt;- na.omit(m)
</code></pre>

<p>This let&#39;s us easily go back to our original data:</p>

<pre><code class="r">m
</code></pre>

<pre><code>##    x y  z
## 1  1 3 NA
## 2  2 2  2
## 3  3 4  3
## 4 NA 5  5
## 5  5 1  4
## 6  7 3  3
## 7  9 4  4
</code></pre>

<pre><code class="r">m2
</code></pre>

<pre><code>##   x y z
## 2 2 2 2
## 3 3 4 3
## 5 5 1 4
## 6 7 3 3
## 7 9 4 4
</code></pre>

<p>Another strategy is some kind of imputation. There are an endless number of options here - and the best way is probably multiple imputation, which is described elsewhere - but two ways to do simple, single imputation is to replace missing values with the means of the other values in the variable or to randomly sample from those values. The former approach (mean imputation) preserves the mean of the variable, whereas the latter approach (random imputation) preserves both the mean and variance. Both might be unreasonable, but its worth seeing how to do them:
To do mean imputation we simply need to identify missing values, calculate the mean of the remaining values, and store that mean into those missing value possitions:</p>

<pre><code class="r">x2 &lt;- x
x2
</code></pre>

<pre><code>## [1]  1  2  3 NA  5  7  9
</code></pre>

<pre><code class="r">is.na(x2)
</code></pre>

<pre><code>## [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
</code></pre>

<pre><code class="r">x2[is.na(x2)]
</code></pre>

<pre><code>## [1] NA
</code></pre>

<pre><code class="r">mean(x2, na.rm = TRUE)
</code></pre>

<pre><code>## [1] 4.5
</code></pre>

<pre><code class="r">x2[is.na(x2)] &lt;- mean(x2, na.rm = TRUE)
x2
</code></pre>

<pre><code>## [1] 1.0 2.0 3.0 4.5 5.0 7.0 9.0
</code></pre>

<p>To do random imputation is a bit more complicated because we need to sample the non-missing values with the <code>sample</code> function, but the process is otherwise similar:</p>

<pre><code class="r">x3 &lt;- x
x3[!is.na(x3)]  # values from which we can sample
</code></pre>

<pre><code>## [1] 1 2 3 5 7 9
</code></pre>

<pre><code class="r">x3[is.na(x3)] &lt;- sample(x3[!is.na(x3)], sum(is.na(x3)), TRUE)
x3
</code></pre>

<pre><code>## [1] 1 2 3 5 5 7 9
</code></pre>

<p>Thus these two imputation strategies produce different resulting data (and those data will reflect the statistical properties of the original data to varying extents), but they mean that all subsequent analysis will not have to worry about missing values.</p>

</body>

</html>

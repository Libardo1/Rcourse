<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Dataframe rearrangement</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



</head>

<body>
<h1>Dataframe rearrangement</h1>

<p>In addition to knowing how to index and view dataframes, as is discussed in other tutorials, it is also helpful to be able to adjust the arrangement of dataframes. By this I mean that it is sometimes helpful to split, sample, reorder, reshape, or otherwise change the organization of a dataframe. This tutorial explains a couple of functions that can help with these kinds of tasks.
Note: One of the most important things to remember about R dataframes is that it rarely, if ever, matters what order observations or variables are have in a dataframe. Whereas in SPSS and SAS observations have to be sorted before performing operations, R does not require such sorting.</p>

<h2>Column order</h2>

<p>Sometimes we want to get dataframe columns in a different order from how they&#39;re read into the data. In most cases, though, we can just index the dataframe to see relevant columns rather reordering, but we can do the reordering if we want.
Say we have the following 5-column dataframe:</p>

<pre><code class="r">set.seed(50)
mydf &lt;- data.frame(a = rep(1:2, each = 10), b = rep(1:4, times = 5), c = rnorm(20), 
    d = rnorm(20), e = sample(1:20, 20, FALSE))
head(mydf)
</code></pre>

<pre><code>##   a b       c       d  e
## 1 1 1  0.5497 -0.3499 11
## 2 1 2 -0.8416 -0.5869  1
## 3 1 3  0.0330 -1.5899  7
## 4 1 4  0.5241  1.6896  8
## 5 1 1 -1.7276  0.5636  9
## 6 1 2 -0.2779  2.6676 19
</code></pre>

<p>To view the columns in a different order, we can simply index the dataframe differently either by name or column position:</p>

<pre><code class="r">head(mydf[, c(3, 4, 5, 1, 2)])
</code></pre>

<pre><code>##         c       d  e a b
## 1  0.5497 -0.3499 11 1 1
## 2 -0.8416 -0.5869  1 1 2
## 3  0.0330 -1.5899  7 1 3
## 4  0.5241  1.6896  8 1 4
## 5 -1.7276  0.5636  9 1 1
## 6 -0.2779  2.6676 19 1 2
</code></pre>

<pre><code class="r">head(mydf[, c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;a&quot;, &quot;b&quot;)])
</code></pre>

<pre><code>##         c       d  e a b
## 1  0.5497 -0.3499 11 1 1
## 2 -0.8416 -0.5869  1 1 2
## 3  0.0330 -1.5899  7 1 3
## 4  0.5241  1.6896  8 1 4
## 5 -1.7276  0.5636  9 1 1
## 6 -0.2779  2.6676 19 1 2
</code></pre>

<p>We can save the adjusted column order if we want:</p>

<pre><code class="r">mydf &lt;- mydf[, c(3, 4, 5, 1, 2)]
head(mydf)
</code></pre>

<pre><code>##         c       d  e a b
## 1  0.5497 -0.3499 11 1 1
## 2 -0.8416 -0.5869  1 1 2
## 3  0.0330 -1.5899  7 1 3
## 4  0.5241  1.6896  8 1 4
## 5 -1.7276  0.5636  9 1 1
## 6 -0.2779  2.6676 19 1 2
</code></pre>

<h2>Row order</h2>

<p>Changing row order works the same way as changing column order. We can simply index the dataframe in a different way. For example, let&#39;s say we want to reverse the order of the dataframe, we can simply write:</p>

<pre><code class="r">mydf[nrow(mydf):1, ]
</code></pre>

<pre><code>##          c        d  e a b
## 20 -0.3234  0.39322  5 2 4
## 19 -1.1660  0.40619  4 2 3
## 18 -0.7653  1.83968  3 2 2
## 17 -0.1568  0.41620 20 2 1
## 16 -0.3629  0.01910  2 2 4
## 15 -0.4555 -1.09605 14 2 3
## 14  0.1957  0.59725  6 2 2
## 13 -0.4986 -1.13045 13 2 1
## 12  0.5548 -0.85142 10 2 4
## 11  0.2952  0.19902 12 2 3
## 10 -1.4457  0.02867 17 1 2
## 9   0.9756  0.56875 18 1 1
## 8  -0.5909 -0.36212 16 1 4
## 7   0.3608  0.35653 15 1 3
## 6  -0.2779  2.66763 19 1 2
## 5  -1.7276  0.56358  9 1 1
## 4   0.5241  1.68956  8 1 4
## 3   0.0330 -1.58988  7 1 3
## 2  -0.8416 -0.58690  1 1 2
## 1   0.5497 -0.34993 11 1 1
</code></pre>

<p>And then we can save this new order if we want:</p>

<pre><code class="r">mydf &lt;- mydf[nrow(mydf):1, ]
</code></pre>

<p>Rarely, however, do we want to just reorder by hand. Instead we might want to reorder according to the values of a column. One&#39;s intuition might be to use the <code>sort</code> function because it is used to sort a vector:</p>

<pre><code class="r">mydf$e
</code></pre>

<pre><code>##  [1]  5  4  3 20  2 14  6 13 10 12 17 18 16 15 19  9  8  7  1 11
</code></pre>

<pre><code class="r">sort(mydf$e)
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
</code></pre>

<p>But trying to run <code>sort(mydf)</code> will produce an error.
Instead, we need to use the <code>order</code> function, which returns the indexes of a sorted vector. Confusing? let&#39;s see how it works:</p>

<pre><code class="r">order(mydf$e)
</code></pre>

<pre><code>##  [1] 19  5  3  2  1  7 18 17 16  9 20 10  8  6 14 13 11 12 15  4
</code></pre>

<p>That doesn&#39;t look like a sorted vector, but this is because the values being shown are the indices of the vector, not the values themselves. If we index the <code>mydf$e</code> vector by the output of <code>order(mydf$e)</code>, it will be in the order we&#39;re expecting:</p>

<pre><code class="r">mydf$e[order(mydf$e)]
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
</code></pre>

<p>We can apply this same logic to sorting a dataframe. We simply pick which column we want to order by and then use the output of <code>order</code> as a row index. Let&#39;s compare the reordered dataframe to the original:</p>

<pre><code class="r">head(mydf[order(mydf$e), ])
</code></pre>

<pre><code>##          c       d e a b
## 2  -0.8416 -0.5869 1 1 2
## 16 -0.3629  0.0191 2 2 4
## 18 -0.7653  1.8397 3 2 2
## 19 -1.1660  0.4062 4 2 3
## 20 -0.3234  0.3932 5 2 4
## 14  0.1957  0.5972 6 2 2
</code></pre>

<pre><code class="r">head(mydf)  # original
</code></pre>

<pre><code>##          c       d  e a b
## 20 -0.3234  0.3932  5 2 4
## 19 -1.1660  0.4062  4 2 3
## 18 -0.7653  1.8397  3 2 2
## 17 -0.1568  0.4162 20 2 1
## 16 -0.3629  0.0191  2 2 4
## 15 -0.4555 -1.0960 14 2 3
</code></pre>

<p>Of course, we could save the reordered dataframe just as above:</p>

<pre><code class="r">mydf &lt;- mydf[order(mydf$e), ]
</code></pre>

<h2>Subset of rows</h2>

<p>Another common operation is to look at a subset of dataframe rows. For example, we might want to look at just the rows where <code>mydf$a==1</code>. Remembering the rules for indexing a dataframe, we can simply index according to a logical rule:</p>

<pre><code class="r">mydf[mydf$a == 1, ]
</code></pre>

<pre><code>##          c        d  e a b
## 2  -0.8416 -0.58690  1 1 2
## 3   0.0330 -1.58988  7 1 3
## 4   0.5241  1.68956  8 1 4
## 5  -1.7276  0.56358  9 1 1
## 1   0.5497 -0.34993 11 1 1
## 7   0.3608  0.35653 15 1 3
## 8  -0.5909 -0.36212 16 1 4
## 10 -1.4457  0.02867 17 1 2
## 9   0.9756  0.56875 18 1 1
## 6  -0.2779  2.66763 19 1 2
</code></pre>

<p>And to get the rows where <code>mydf$a==2</code>, we can do quite the same operation:</p>

<pre><code class="r">mydf[mydf$a == 2, ]
</code></pre>

<pre><code>##          c       d  e a b
## 16 -0.3629  0.0191  2 2 4
## 18 -0.7653  1.8397  3 2 2
## 19 -1.1660  0.4062  4 2 3
## 20 -0.3234  0.3932  5 2 4
## 14  0.1957  0.5972  6 2 2
## 12  0.5548 -0.8514 10 2 4
## 11  0.2952  0.1990 12 2 3
## 13 -0.4986 -1.1304 13 2 1
## 15 -0.4555 -1.0960 14 2 3
## 17 -0.1568  0.4162 20 2 1
</code></pre>

<p>We can also combine logical rules to get a further subset of values:</p>

<pre><code class="r">mydf[mydf$a == 1 &amp; mydf$b == 4, ]
</code></pre>

<pre><code>##         c       d  e a b
## 4  0.5241  1.6896  8 1 4
## 8 -0.5909 -0.3621 16 1 4
</code></pre>

<p>And we need to restrict ourselves to equivalency logicals:</p>

<pre><code class="r">mydf[mydf$a == 1 &amp; mydf$b &gt; 2, ]
</code></pre>

<pre><code>##         c       d  e a b
## 3  0.0330 -1.5899  7 1 3
## 4  0.5241  1.6896  8 1 4
## 7  0.3608  0.3565 15 1 3
## 8 -0.5909 -0.3621 16 1 4
</code></pre>

<p>R also supplies a <code>subset</code> function, which can be used to select subsets of rows, subsets of columns, or both. It works like so:</p>

<pre><code class="r"># subset of rows:
subset(mydf, a == 1)
</code></pre>

<pre><code>##          c        d  e a b
## 2  -0.8416 -0.58690  1 1 2
## 3   0.0330 -1.58988  7 1 3
## 4   0.5241  1.68956  8 1 4
## 5  -1.7276  0.56358  9 1 1
## 1   0.5497 -0.34993 11 1 1
## 7   0.3608  0.35653 15 1 3
## 8  -0.5909 -0.36212 16 1 4
## 10 -1.4457  0.02867 17 1 2
## 9   0.9756  0.56875 18 1 1
## 6  -0.2779  2.66763 19 1 2
</code></pre>

<pre><code class="r">subset(mydf, a == 1 &amp; b &gt; 2)
</code></pre>

<pre><code>##         c       d  e a b
## 3  0.0330 -1.5899  7 1 3
## 4  0.5241  1.6896  8 1 4
## 7  0.3608  0.3565 15 1 3
## 8 -0.5909 -0.3621 16 1 4
</code></pre>

<pre><code class="r"># subset of columns:
subset(mydf, select = c(&quot;a&quot;, &quot;b&quot;))
</code></pre>

<pre><code>##    a b
## 2  1 2
## 16 2 4
## 18 2 2
## 19 2 3
## 20 2 4
## 14 2 2
## 3  1 3
## 4  1 4
## 5  1 1
## 12 2 4
## 1  1 1
## 11 2 3
## 13 2 1
## 15 2 3
## 7  1 3
## 8  1 4
## 10 1 2
## 9  1 1
## 6  1 2
## 17 2 1
</code></pre>

<pre><code class="r"># subset of rows and columns:
subset(mydf, a == 1 &amp; b &gt; 2, select = c(&quot;c&quot;, &quot;d&quot;))
</code></pre>

<pre><code>##         c       d
## 3  0.0330 -1.5899
## 4  0.5241  1.6896
## 7  0.3608  0.3565
## 8 -0.5909 -0.3621
</code></pre>

<p>Using indices and <code>subset</code> are equivalent, but the indexing syntax is more general.</p>

<h2>Splitting a dataframe</h2>

<p>In one of the above examples, we extracted two separate dataframes: one for <code>mydf$a==1</code> and one for <code>mydf$a==2</code>. We can actually achieve that result using a single line of code involving the <code>split</code> function, which returns a list of dataframes, separated out by a grouping factor:</p>

<pre><code class="r">split(mydf, mydf$a)
</code></pre>

<pre><code>## $`1`
##          c        d  e a b
## 2  -0.8416 -0.58690  1 1 2
## 3   0.0330 -1.58988  7 1 3
## 4   0.5241  1.68956  8 1 4
## 5  -1.7276  0.56358  9 1 1
## 1   0.5497 -0.34993 11 1 1
## 7   0.3608  0.35653 15 1 3
## 8  -0.5909 -0.36212 16 1 4
## 10 -1.4457  0.02867 17 1 2
## 9   0.9756  0.56875 18 1 1
## 6  -0.2779  2.66763 19 1 2
## 
## $`2`
##          c       d  e a b
## 16 -0.3629  0.0191  2 2 4
## 18 -0.7653  1.8397  3 2 2
## 19 -1.1660  0.4062  4 2 3
## 20 -0.3234  0.3932  5 2 4
## 14  0.1957  0.5972  6 2 2
## 12  0.5548 -0.8514 10 2 4
## 11  0.2952  0.1990 12 2 3
## 13 -0.4986 -1.1304 13 2 1
## 15 -0.4555 -1.0960 14 2 3
## 17 -0.1568  0.4162 20 2 1
</code></pre>

<p>We can also split by multiple factors, e.g., a dataframe for every unique combination of <code>mydf$a</code> and <code>mydf$b</code>:</p>

<pre><code class="r">split(mydf, list(mydf$a, mydf$b))
</code></pre>

<pre><code>## $`1.1`
##         c       d  e a b
## 5 -1.7276  0.5636  9 1 1
## 1  0.5497 -0.3499 11 1 1
## 9  0.9756  0.5687 18 1 1
## 
## $`2.1`
##          c       d  e a b
## 13 -0.4986 -1.1304 13 2 1
## 17 -0.1568  0.4162 20 2 1
## 
## $`1.2`
##          c        d  e a b
## 2  -0.8416 -0.58690  1 1 2
## 10 -1.4457  0.02867 17 1 2
## 6  -0.2779  2.66763 19 1 2
## 
## $`2.2`
##          c      d e a b
## 18 -0.7653 1.8397 3 2 2
## 14  0.1957 0.5972 6 2 2
## 
## $`1.3`
##        c       d  e a b
## 3 0.0330 -1.5899  7 1 3
## 7 0.3608  0.3565 15 1 3
## 
## $`2.3`
##          c       d  e a b
## 19 -1.1660  0.4062  4 2 3
## 11  0.2952  0.1990 12 2 3
## 15 -0.4555 -1.0960 14 2 3
## 
## $`1.4`
##         c       d  e a b
## 4  0.5241  1.6896  8 1 4
## 8 -0.5909 -0.3621 16 1 4
## 
## $`2.4`
##          c       d  e a b
## 16 -0.3629  0.0191  2 2 4
## 20 -0.3234  0.3932  5 2 4
## 12  0.5548 -0.8514 10 2 4
</code></pre>

<p>Having our dataframes stored inside another object might seem inconvenient, but it actually is vary useful because we can use functions like <code>lapply</code> to perform an operation on every dataframe in the list. For example, we could get the summary of every variable in each of two subsets of the dataframe in a single line of code:</p>

<pre><code class="r">lapply(split(mydf, mydf$a), summary)
</code></pre>

<pre><code>## $`1`
##        c                d                e               a    
##  Min.   :-1.728   Min.   :-1.590   Min.   : 1.00   Min.   :1  
##  1st Qu.:-0.779   1st Qu.:-0.359   1st Qu.: 8.25   1st Qu.:1  
##  Median :-0.122   Median : 0.193   Median :13.00   Median :1  
##  Mean   :-0.244   Mean   : 0.299   Mean   :12.10   Mean   :1  
##  3rd Qu.: 0.483   3rd Qu.: 0.568   3rd Qu.:16.75   3rd Qu.:1  
##  Max.   : 0.976   Max.   : 2.668   Max.   :19.00   Max.   :1  
##        b       
##  Min.   :1.00  
##  1st Qu.:1.25  
##  Median :2.00  
##  Mean   :2.30  
##  3rd Qu.:3.00  
##  Max.   :4.00  
## 
## $`2`
##        c                d                 e               a    
##  Min.   :-1.166   Min.   :-1.1304   Min.   : 2.00   Min.   :2  
##  1st Qu.:-0.488   1st Qu.:-0.6338   1st Qu.: 4.25   1st Qu.:2  
##  Median :-0.343   Median : 0.2961   Median : 8.00   Median :2  
##  Mean   :-0.268   Mean   : 0.0793   Mean   : 8.90   Mean   :2  
##  3rd Qu.: 0.108   3rd Qu.: 0.4137   3rd Qu.:12.75   3rd Qu.:2  
##  Max.   : 0.555   Max.   : 1.8397   Max.   :20.00   Max.   :2  
##        b       
##  Min.   :1.00  
##  1st Qu.:2.00  
##  Median :3.00  
##  Mean   :2.70  
##  3rd Qu.:3.75  
##  Max.   :4.00
</code></pre>

<h2>Sampling and permutations</h2>

<p>Another common task is random sampling or permutation of rows in a dataframe. For example, we might want to build a regression model on a random subset of cases (a &ldquo;training set&rdquo;) and then test the model on the remaining case (a &ldquo;test set&rdquo;). Or, we might want to look at a random sample of the observations (e.g., perhaps to speed up a very time-consuming analysis).
Let&#39;s consider the case of sampling for &ldquo;training&rdquo; and &ldquo;test&rdquo; sets. To obtain a random sample, we have two choices. We can either sample a specified number of rows or we can use a logical index to sample rows based on a specified probability. Both use the <code>sample</code> function.
To look at, e.g., exactly five randomly selected rows from our data frame as the training set, we can do the following:</p>

<pre><code class="r">s &lt;- sample(1:nrow(mydf), 5, FALSE)
s
</code></pre>

<pre><code>## [1] 11 19 12  1 17
</code></pre>

<p>Note: The third argument (<code>FALSE</code>) refers to whether sampling should be done with replacement.
We can then use that directly as a row index:</p>

<pre><code class="r">mydf[s, ]
</code></pre>

<pre><code>##          c        d  e a b
## 1   0.5497 -0.34993 11 1 1
## 6  -0.2779  2.66763 19 1 2
## 11  0.2952  0.19902 12 2 3
## 2  -0.8416 -0.58690  1 1 2
## 10 -1.4457  0.02867 17 1 2
</code></pre>

<p>To see the test set, we simply drop all rows not in <code>s</code>:</p>

<pre><code class="r">mydf[-s, ]
</code></pre>

<pre><code>##          c       d  e a b
## 16 -0.3629  0.0191  2 2 4
## 18 -0.7653  1.8397  3 2 2
## 19 -1.1660  0.4062  4 2 3
## 20 -0.3234  0.3932  5 2 4
## 14  0.1957  0.5972  6 2 2
## 3   0.0330 -1.5899  7 1 3
## 4   0.5241  1.6896  8 1 4
## 5  -1.7276  0.5636  9 1 1
## 12  0.5548 -0.8514 10 2 4
## 13 -0.4986 -1.1304 13 2 1
## 15 -0.4555 -1.0960 14 2 3
## 7   0.3608  0.3565 15 1 3
## 8  -0.5909 -0.3621 16 1 4
## 9   0.9756  0.5687 18 1 1
## 17 -0.1568  0.4162 20 2 1
</code></pre>

<p>An alternative is to get a random 20% of the rows but not require that to be exactly five observations. To do that, we make 20 random draws (i.e., a number of draws equal to the number of rows in our dataframe) from a binomial distribution with probability .2:</p>

<pre><code class="r">s2 &lt;- rbinom(nrow(mydf), 1, 0.2)
s2
</code></pre>

<pre><code>##  [1] 1 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0
</code></pre>

<p>We can then use that directly as a row index:</p>

<pre><code class="r">mydf[s2, ]
</code></pre>

<pre><code>##           c       d e a b
## 2   -0.8416 -0.5869 1 1 2
## 2.1 -0.8416 -0.5869 1 1 2
## 2.2 -0.8416 -0.5869 1 1 2
## 2.3 -0.8416 -0.5869 1 1 2
</code></pre>

<p>And again see the test set as those observations not in <code>s2</code>.</p>

<pre><code class="r">mydf[!s2, ]
</code></pre>

<pre><code>##          c        d  e a b
## 16 -0.3629  0.01910  2 2 4
## 18 -0.7653  1.83968  3 2 2
## 20 -0.3234  0.39322  5 2 4
## 3   0.0330 -1.58988  7 1 3
## 4   0.5241  1.68956  8 1 4
## 5  -1.7276  0.56358  9 1 1
## 12  0.5548 -0.85142 10 2 4
## 1   0.5497 -0.34993 11 1 1
## 11  0.2952  0.19902 12 2 3
## 13 -0.4986 -1.13045 13 2 1
## 15 -0.4555 -1.09605 14 2 3
## 8  -0.5909 -0.36212 16 1 4
## 10 -1.4457  0.02867 17 1 2
## 9   0.9756  0.56875 18 1 1
## 6  -0.2779  2.66763 19 1 2
## 17 -0.1568  0.41620 20 2 1
</code></pre>

<p>Note: Here we use <code>!s2</code> because <code>s2</code> is a logical index, whereas above we used <code>-s</code> because <code>s</code> was a positional index.</p>

</body>

</html>

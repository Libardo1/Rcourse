<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Model Formulae</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



</head>

<body>
<h1>Model Formulae</h1>

<p>One of the most important object classes for statistics in R is the &ldquo;formula&rdquo; class. Formula objects, while unimportant for R in general, are critical to many of statistical tests and statistical plots in R (as well as many add-on packages). Formulae convey a relationship among a set of variables in a simple, intuitive way. They are also data-independent, meaning that a formula can be constructed and then used with application to different dataframes or subsets of a dataframe. This means we can define formulae without having any data loaded.
Note: We did not discuss formulas in the tutorials on object classes, because they are not one of the fundamental classes needed throughout R. They are only needed for statistical procedures, which we happen to need a lot in academic research but aren&#39;t as critical in other uses of R.</p>

<h2>Formula basics</h2>

<p>The basic structure of a formula is the tilde symbol (<code>~</code>) and at least one independent (righthand) variable. In most (but not all) situations, a single dependent (lefthand) variable is also needed.
Thus we can construct a formula quite simply by just typing:</p>

<pre><code class="r">~x
</code></pre>

<pre><code>## ~x
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>Note: Spaces in formulae are not important.
And, like any other object, we can store this as an R variable and see that it is, in fact, a formula:</p>

<pre><code class="r">myformula &lt;- ~x
class(myformula)
</code></pre>

<pre><code>## [1] &quot;formula&quot;
</code></pre>

<p>More commonly, we want to express a formula as a relationship between an outcome (lefthand) variable and one or more independent/predictor/covariate (righthand) variables:</p>

<pre><code class="r">myformula &lt;- y ~ x
</code></pre>

<p>We can use multiple independent variables by simply separating them with the plus (<code>+</code>) symbol:</p>

<pre><code class="r">y ~ x1 + x2
</code></pre>

<pre><code>## y ~ x1 + x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>If we use a minus (<code>-</code>) symbol, objects in the formula are ignored in an analysis:</p>

<pre><code class="r">y ~ x1 - x2
</code></pre>

<pre><code>## y ~ x1 - x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>One particularly helpful feature when modelling with lots of variables is the <code>.</code> operator. When used in a formula, <code>.</code> refers to all other variables in the matrix not yet included in the model. So, if we plan to run a regression on a matrix (or dataframe) containing the variables <code>y</code>, <code>x1</code>, <code>z3</code>, and <code>areallylongvariablename</code>, we can simply use the formula:</p>

<pre><code class="r">y ~ .
</code></pre>

<pre><code>## y ~ .
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>and avoid having to type all of the variables.</p>

<h2>Interaction terms</h2>

<p>In a regression modeling context, we often need to specify interaction terms. There are two ways to do this.
If we want to include two variables and their interaction, we use the star/asterisk (<code>*</code>) symbol:</p>

<pre><code class="r">y ~ x1 * x2
</code></pre>

<pre><code>## y ~ x1 * x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>If we only want their interaction, but not the variables themselves, we use the colon (<code>:</code>) symbol:</p>

<pre><code class="r">y ~ x1:x2
</code></pre>

<pre><code>## y ~ x1:x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>Note: We probably don&#39;t want to do this.
This means that some formulae that look different are actually equivalent. The following formulae will produce the same regression:</p>

<pre><code class="r">y ~ x1 * x2
</code></pre>

<pre><code>## y ~ x1 * x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r">y ~ x1 + x2 + x1:x2
</code></pre>

<pre><code>## y ~ x1 + x2 + x1:x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<h2>Regression formulae</h2>

<p>In regression models, we may also want to know a few other tricks.
One trick is to drop the intercept, by either including a zero (<code>0</code>) or a minus-one (<code>-1</code>) in the formula:</p>

<pre><code class="r">y ~ -1 + x1 * x2
</code></pre>

<pre><code>## y ~ -1 + x1 * x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r">y ~ 0 + x1 * x2
</code></pre>

<pre><code>## y ~ 0 + x1 * x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>We can also offset the intercept of a model using the <code>offset</code> function. The use is kind of strange and not that common, but we can increase the intercept by, e.g., 2 using:</p>

<pre><code class="r">y ~ x1 + offset(rep(-2, n))
</code></pre>

<pre><code>## y ~ x1 + offset(rep(-2, n))
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>or reduce the intercept by, e.g., 3 using:</p>

<pre><code class="r">y ~ x1 + offset(rep(3, n))
</code></pre>

<pre><code>## y ~ x1 + offset(rep(3, n))
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>Note: The <code>n</code> here would have to be tailed to the length of the actual. It&#39;s unclear in what context this functionality is really helpful, but it does mean that models can be adjusted in fairly sophisticated ways.</p>

<h2>Factor variables</h2>

<p>An important consideration in regression formulae is the handling of factor-class variables. When a factor is included in a regression model, it is automatically converted into a series of indicator (&ldquo;dummy&rdquo;) variables, with the factor&#39;s first level treated as a baseline. This also means that we can convert non-factor variables into a series of dummies, simply by wrapping them in <code>factor</code>:</p>

<pre><code class="r">y ~ x
</code></pre>

<pre><code>## y ~ x
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r"># to:
y ~ factor(x)
</code></pre>

<pre><code>## y ~ factor(x)
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<h2>As-is variables</h2>

<p>One trick to formulas is that they don&#39;t evaluate their contents. So, for example, if we wanted to include <code>x</code> and <code>x^2</code> in our model, we might intuit that we should type:</p>

<pre><code class="r">y ~ x + x^2
</code></pre>

<pre><code>## y ~ x + x^2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>If we attempted to estimate a regression model using this formula, R would drop the <code>x^2</code> term because it thinks it is a duplicate of <code>x</code>. We therefore have to either calculate and store all of the variables we want to include in the model in advance, or we need to use the <code>I()</code> &ldquo;as-is&rdquo; operator.
To obtain our desired two-term formula, we could use <code>I()</code> as follows:</p>

<pre><code class="r">y ~ x + I(x^2)
</code></pre>

<pre><code>## y ~ x + I(x^2)
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>This tells R to calculate the values of <code>x^2</code> before attempting to use the formula.
Aside from calculating powers, <code>I()</code> can also be helpful when we want to rescale a variable for a model (e.g., to make two coefficients more comparable by using a common scale). Again, we simply wrap the relevant variable name in <code>I()</code>:</p>

<pre><code class="r">y ~ I(2 * x)
</code></pre>

<pre><code>## y ~ I(2 * x)
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>This formula would, in a linear regression, produce a coefficient half as large as the model for <code>y~x</code>.</p>

<h2>Formulae as character strings</h2>

<p>One might be tempted to compare a formula to a character string. They look similar, but they are different. Their similar means, however, that a character string containing a formula can often be used where a formula-class object is required. Indeed the following is true:</p>

<pre><code class="r">(&quot;y ~ x&quot;) == (y ~ x)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>And we can easily convert between formula and character class:</p>

<pre><code class="r">as.formula(&quot;y~x&quot;)
</code></pre>

<pre><code>## y ~ x
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r">as.character(y ~ x)
</code></pre>

<pre><code>## [1] &quot;~&quot; &quot;y&quot; &quot;x&quot;
</code></pre>

<p>Note: The result of the latter is probably not what you expected. But relates to how formulae are indexed:</p>

<pre><code class="r">(y ~ x)[1]
</code></pre>

<pre><code>## `~`()
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r">(y ~ x)[2]
</code></pre>

<pre><code>## y()
</code></pre>

<pre><code class="r">(y ~ x)[3]
</code></pre>

<pre><code>## x()
</code></pre>

<p>The ability to easily transform between formula and character class means that we can also build formulae on the fly using <code>paste</code>. For example, if we want to add righthand variables to a formula, we can simply paste them:</p>

<pre><code class="r">paste(&quot;y~x&quot;, &quot;x2&quot;, &quot;x3&quot;, sep = &quot;+&quot;)
</code></pre>

<pre><code>## [1] &quot;y~x+x2+x3&quot;
</code></pre>

<h2>Advanced formula manipulation</h2>

<p>One of the really nice features of formulae is that they have many methods. For example, we can use the <code>terms</code> function to examine and compare different formulae:</p>

<pre><code class="r">terms(y ~ x1 + x2)
</code></pre>

<pre><code>## y ~ x1 + x2
## attr(,&quot;variables&quot;)
## list(y, x1, x2)
## attr(,&quot;factors&quot;)
##    x1 x2
## y   0  0
## x1  1  0
## x2  0  1
## attr(,&quot;term.labels&quot;)
## [1] &quot;x1&quot; &quot;x2&quot;
## attr(,&quot;order&quot;)
## [1] 1 1
## attr(,&quot;intercept&quot;)
## [1] 1
## attr(,&quot;response&quot;)
## [1] 1
## attr(,&quot;.Environment&quot;)
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r">terms(y ~ 0 + x1)
</code></pre>

<pre><code>## y ~ 0 + x1
## attr(,&quot;variables&quot;)
## list(y, x1)
## attr(,&quot;factors&quot;)
##    x1
## y   0
## x1  1
## attr(,&quot;term.labels&quot;)
## [1] &quot;x1&quot;
## attr(,&quot;order&quot;)
## [1] 1
## attr(,&quot;intercept&quot;)
## [1] 0
## attr(,&quot;response&quot;)
## [1] 1
## attr(,&quot;.Environment&quot;)
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r">terms(~x1 + x2)
</code></pre>

<pre><code>## ~x1 + x2
## attr(,&quot;variables&quot;)
## list(x1, x2)
## attr(,&quot;factors&quot;)
##    x1 x2
## x1  1  0
## x2  0  1
## attr(,&quot;term.labels&quot;)
## [1] &quot;x1&quot; &quot;x2&quot;
## attr(,&quot;order&quot;)
## [1] 1 1
## attr(,&quot;intercept&quot;)
## [1] 1
## attr(,&quot;response&quot;)
## [1] 0
## attr(,&quot;.Environment&quot;)
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>The output above shows the formula itself, a list of its constitutive variables, the presence of intercept, the presence of an outcome, and so forth.
If we just want to know the names of the variables in the model, we can use <code>all.vars</code>:</p>

<pre><code class="r">all.vars(y ~ x1 + x2)
</code></pre>

<pre><code>## [1] &quot;y&quot;  &quot;x1&quot; &quot;x2&quot;
</code></pre>

<p>We can also modify formulae without converting them to character (as we did above), using the <code>update</code> function. This potentially saves a lot of typing:</p>

<pre><code class="r">update(y ~ x, ~. + x2)
</code></pre>

<pre><code>## y ~ x + x2
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<pre><code class="r">update(y ~ x, z ~ .)
</code></pre>

<pre><code>## z ~ x
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>This could be used, e.g., to run a model on a &ldquo;small&rdquo; model and then a larger version:</p>

<pre><code class="r">myformula &lt;- y ~ a + b + c
update(myformula, &quot;~.+d+e+f&quot;)
</code></pre>

<pre><code>## y ~ a + b + c + d + e + f
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>Or the same righthand variables to predict two different outcomes:</p>

<pre><code class="r">update(myformula, &quot;z~.&quot;)
</code></pre>

<pre><code>## z ~ a + b + c
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

<p>We can also drop terms using <code>update</code>:</p>

<pre><code class="r">update(myformula, &quot;~.-a&quot;)
</code></pre>

<pre><code>## y ~ b + c
## &lt;environment: 0x0000000024adecd0&gt;
</code></pre>

</body>

</html>
